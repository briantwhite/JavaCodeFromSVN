//TBSApplet: the runnable frame class of TBS

package tbs;

import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.RenderingHints;
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URL;
import java.net.URLConnection;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.TreeSet;

import javax.imageio.ImageIO;
import javax.swing.JApplet;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;

import tbs.controller.AdminController;
import tbs.controller.StudentController;
import tbs.graphanalysis.CorrectTreeBipartitionSet;
import tbs.graphanalysis.Edge;
import tbs.graphanalysis.Graph;
import tbs.graphanalysis.Vertex;
import tbs.model.AdminModel;
import tbs.model.Connection;
import tbs.model.ModelElement;
import tbs.model.Node;
import tbs.model.OrganismNode;
import tbs.model.StudentModel;
import tbs.model.TBSModel;
import tbs.model.admin.Response;
import tbs.model.admin.Student;
import tbs.properties.PropertyLoader;
import tbs.view.AdminView;
import tbs.view.OpenQuestionButtonType;
import tbs.view.StudentView;
import tbs.view.prompt.Prompt;
import tbs.view.prompt.student.ResizeWarningPrompt;
import tbs.view.prompt.student.WelcomePrompt;
import tbs.view.prompt.student.WrittenQuestionPrompt;

/**
 * TBSApplet is the frame in which the Tree-Building System runs. Its function
 * is to initialize the major classes of the applet and to load in the initial
 * data.
 */
public class TBSApplet extends JApplet {

	/**
	 * 8-byte serialization class ID generated by
	 * https://www.fourmilab.ch/hotbits/secure_generate.html
	 */
	private static final long serialVersionUID = 0x03046F6687102247L;

	public static final String VERSION = "2.1";

	private TBSModel model;
	private TBSApplet app = this;
	private boolean admin;
	private String browser;

	private List<OrganismNode> organisms;

	/**
	 * INIT instantiates TBSGraphics and TBSModel, and calls the
	 * loadOrganismsFromDirectory method in order to populate the initial set of
	 * OrganismNodes.
	 */
	public void init() {

		EventQueue.invokeLater(new Runnable() {
			public void run() {

				TBSGraphics.appletWidth = getWidth();
				TBSGraphics.appletHeight = getHeight();
				browser = getParameter("Browser");
				TBSGraphics.updateBrowserSpecs(browser);
				Graphics2D g2 = (Graphics2D) getGraphics();
				RenderingHints rh = new RenderingHints(
						RenderingHints.KEY_TEXT_ANTIALIASING,
						RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
				g2.setRenderingHints(rh);
				g2.setFont(TBSGraphics.font);

				// Update some constants
				TBSGraphics.textHeight = TBSGraphics
				.getStringBounds(g2, "QOgj").height;
				TBSGraphics.checkWidth = TBSGraphics.getStringBounds(g2,
				" \u2713").width;
				TBSGraphics.arrowWidth = TBSGraphics.getStringBounds(g2,
				" \u2192").width;
				TBSGraphics.groupCtWidth = TBSGraphics.getStringBounds(g2,
				" (3)").width;
				TBSGraphics.RGBEntryBoxWidth = TBSGraphics.getStringBounds(g2,
				"000").width;

				PropertyLoader.loaderLocation = this.getClass();
				organisms = loadOrganisms(g2);
				String adminStr = getParameter("Admin");
				admin = Boolean.parseBoolean(adminStr);
				String studentDataString;
				if (!admin) {
					studentDataString = getParameter("student");
					StudentModel studentModel = new StudentModel(app,
							organisms, studentDataString);
					StudentView view = new StudentView(g2, studentModel);
					StudentController controller = new StudentController(
							studentModel, view);
					studentModel.setView(view);
					studentModel.setController(controller);
					if (view.getWidth() <= 945 || view.getHeight() <= 575)
						studentModel.setPrompt(new ResizeWarningPrompt(model,
								view.getWidth()));
					else
						studentModel.setPrompt(new WelcomePrompt(studentModel));
					model = studentModel;

					Boolean scoreMany = Boolean.parseBoolean(getParameter("ScoreMany"));
					if (scoreMany) {
						openManyTreesForScoring();
					}
				} else {
					List<Student> students = loadStudents(g2, getParameter("student"));
					if (students == null) {
						JOptionPane.showMessageDialog(null, "No .tree files were found; exiting.");
						System.exit(0);
					}
					AdminModel adminModel = new AdminModel(app, organisms,
							students);
					AdminView view = new AdminView(g2, adminModel);
					AdminController controller = new AdminController(
							adminModel, view);
					adminModel.setView(view);
					adminModel.setController(controller);
					model = adminModel;

				}
				add(model.getView());
				model.getView().addMouseListener(model.getController());
				model.getView().addMouseMotionListener(model.getController());
				model.getView().addKeyListener(model.getController());
				model.getView().addComponentListener(model.getController());

			}
		});
	}

	/**
	 * Initialize ModelElements with names and images of Organisms for this
	 * task. The initial data for this program is a flat comma-delimited text
	 * file containing each organism's name, name of the image file containing
	 * its icon, and the class to which it is assigned for scoring purposes.
	 * LoadImageOrganisms reads and parses this text file to populate the
	 * ModelElements list with the organisms the student is to use in building
	 * his or her tree.
	 */
	public List<OrganismNode> loadOrganisms(Graphics2D g2) {
		List<OrganismNode> organisms = new LinkedList<OrganismNode>();
		Properties props;
		String imageFilename = "";
		try {
			props = PropertyLoader.loadPropertyFile("organisms");
			if (props.size() == 0)
				return new LinkedList<OrganismNode>();
			TBSGraphics.numOfOrganisms = props.size();
			BufferedImage img = null;
			String name, value;
			List<String> splitValue;
			int i = 0;
			Set<String> keys = new TreeSet<String>();
			for (Object o : props.keySet())
				keys.add(o.toString());
			for (String key : keys) {
				name = key.replace("_", " ");
				Dimension d = TBSGraphics.getStringBounds(g2, name);
				if (d.width > TBSGraphics.maxOrganismStringWidth)
					TBSGraphics.maxOrganismStringWidth = d.width;
				if (d.height > TBSGraphics.maxOrganismStringHeight)
					TBSGraphics.maxOrganismStringHeight = d.height;
				value = props.getProperty(key).toString();
				splitValue = Arrays.asList(value.split(","));
				imageFilename = new StringBuffer("images/").append(
						splitValue.get(0)).toString();
				URL imageURL = this.getClass().getResource(imageFilename);
				URLConnection imageconn = (URLConnection) imageURL
				.openConnection();
				imageconn.setRequestProperty("REFERER", getDocumentBase()
						.toString());
				InputStream imageis = imageconn.getInputStream();
				img = ImageIO.read(imageis);
				if (img.getWidth() > TBSGraphics.maxOrganismImageWidth)
					TBSGraphics.maxOrganismImageWidth = img.getWidth();
				if (img.getHeight() > TBSGraphics.maxOrganismImageHeight)
					TBSGraphics.maxOrganismImageHeight = img.getHeight();
				organisms.add(new OrganismNode(i, name, splitValue.subList(1,
						splitValue.size()), new Point(), img, d.width));
				imageis.close();
				i++;
			}
		} catch (Exception e) {
			System.out.println(new StringBuffer("Error loading image ").append(
					imageFilename).append(": ").append(e).toString());
			return organisms;
		}
		return organisms;
	}

	public List<Student> loadStudents(Graphics2D g2, int studentParameterCount) {
		TBSGraphics.studentNodeHeight = 0;
		List<Student> students = new LinkedList<Student>();
		int lines = 0;
		String studentDataString;
		for (int i = 1; i <= studentParameterCount; i++) {
			studentDataString = getParameter("student" + i);
			Student temp = new Student(studentDataString, i - 1);
			temp.setNodeName(TBSGraphics.breakStringByLineWidth(g2, temp
					.getName(), TBSGraphics.maxStudentNameWidth));
			if (temp.getNodeName().size() > lines)
				lines = temp.getNodeName().size();
			students.add(temp);
		}
		TBSGraphics.studentNodeHeight = lines * TBSGraphics.textHeight;
		TBSGraphics.studentNodeHeight += TBSGraphics.padding.width * 2;
		return students;
	}

	/**
	 * Read a file and return a list of Strings, one String per Node.
	 */
	public List<String> loadTreeFile(String fileName) {
		URL fileURL = null;
		URLConnection conn = null;
		InputStream is = null;
		BufferedReader reader = null;
		ArrayList<String> lines = new ArrayList<String>();
		String line = "";
		try {
			fileURL = new URL(getCodeBase(), fileName);
			System.out.println("Got a file");
			conn = (URLConnection) fileURL.openConnection();
			conn.setRequestProperty("REFERER", getDocumentBase().toString());
			is = conn.getInputStream();
			reader = new BufferedReader(new InputStreamReader(is));
			line = null;
			while ((line = reader.readLine()) != null) {
				lines.add(line);
			}
			is.close();
		} catch (Exception e) {
			System.out.println("loadTreeFile: " + e);
			e.printStackTrace();
		}
		return lines;
	}

	public String getTree() {
		return model.exportTree();
	}

	public String getQ1() {
		Map<OpenQuestionButtonType, Response> responses = model.getStudent()
		.getResponses();
		if (responses.containsKey(OpenQuestionButtonType.values()[0]))
			return responses.get(OpenQuestionButtonType.values()[0]).getText();
		else
			return "";
	}

	public String getQ2() {
		Map<OpenQuestionButtonType, Response> responses = model.getStudent()
		.getResponses();
		if (responses.containsKey(OpenQuestionButtonType.values()[1]))
			return responses.get(OpenQuestionButtonType.values()[1]).getText();
		else
			return "";
	}

	public String getQ3() {
		Map<OpenQuestionButtonType, Response> responses = model.getStudent()
		.getResponses();
		if (responses.containsKey(OpenQuestionButtonType.values()[2]))
			return responses.get(OpenQuestionButtonType.values()[2]).getText();
		else
			return "";
	}

	public String getStatus() {
		if (admin)
			return "";
		else {
			StudentModel m = (StudentModel) model;
			StringBuffer status = new StringBuffer(m.surveyStatus());
			String unusedOrganisms = m.unusedOrganisms();
			if (status.length() > 0) {
				status.append("\n\n");
				if (unusedOrganisms.length() > 0)
					status
					.append(
					"Also, you have not used the following organisms:\n")
					.append(m.unusedOrganisms());
			} else {
				if (unusedOrganisms.length() > 0)
					status.append(
					"You have not used the following organisms:\n")
					.append(m.unusedOrganisms());
			}
			return status.toString();
		}
	}

	public String questionInProgress() {
		Prompt p = model.getPrompt();
		if (p instanceof WrittenQuestionPrompt)
			return ((WrittenQuestionPrompt) p).getCurrentQuestion().getText();
		return "";
	}

	public void acceptQuestionInProgress() {
		WrittenQuestionPrompt p = (WrittenQuestionPrompt) model.getPrompt();
		p.forceAcceptChanges();
	}

	public String[][] getParameterInfo() {
		String[][] parameterInfo = null;
		if (admin) {
			parameterInfo = new String[4][];
			parameterInfo[0] = new String[] {
					"Admin",
					"Boolean",
			"This tells the applet to run the admin version if true & the student version if false" };
			parameterInfo[1] = new String[] {
					"StudentCount",
					"Integer",
			"In admin mode this parameter tells the applet how many 'Student' parameters to get" };
			parameterInfo[2] = new String[] {
					"Student(#)",
					"String",
			"This contains the student data(name, last update date, tree, open-responses, section [used for has arrows or not]) for each student" };
			parameterInfo[3] = new String[] { "Browser", "String",
			"This contains information about the browser that has accessed this applet" };
		} else {
			parameterInfo = new String[3][];
			parameterInfo[0] = new String[] {
					"Admin",
					"Boolean",
			"This tells the applet to run the admin version if true & the student version if false" };
			parameterInfo[1] = new String[] {
					"Student",
					"String",
			"This contains the student data(name, last update date, tree, open-responses, section [used for has arrows or not]) for this student" };
			parameterInfo[2] = new String[] { "Browser", "String",
			"This contains information about the browser that has accessed this applet" };
		}
		return parameterInfo;
	}

	public String getAppletInfo() {
		return "Diversity of Life Survey Applet, Version 1.3\n"
		+ "Copyright Tree Building Survey Group,2010";
	}

	public static void main(String[] args) {
		final TBSApplet applet = new TBSApplet();
		ApplicationFrame frame = new ApplicationFrame(applet, VERSION, args);
		frame.setVisible(true);				
	}

	public String getScore() {
		StudentModel m = (StudentModel) model;

		StringBuffer b = new StringBuffer();
		b.append("<html>");

		if (m.unusedOrganisms().length() != 0) {
			b.append("<font size=-2>You have not <font color=red>used</font> all the organisms.</font></html>");
			return b.toString();
		}

		Graph graph = makeGraph(m);
		
		if (!graph.allOrganismsConnected()) {
			b.append("<font size=-2>You have not <font color=green>connected</font> all the organisms.</font></html>");
			return b.toString();
		}

		if (!graph.allOrganismsTerminal()) {
			b.append("<font size=-2>All of your living organisms are <font color=green>not at the ends of branches</font>.</font></html>");
			return b.toString();
		}
		
		if (graph.hasUnconnectedBranchPoints()) {
			b.append("<font size=-2>You have some <font color=purple>branch points</font> that are not connected to anything.</font></html>");
			return b.toString();
		}
		
		if (graph.hasTerminalBranchPoints()) {
			b.append("<font size=-2>You have some <font color=purple>branch points</font> that are at the ends of lines.</font></html>");
			return b.toString();
		}

		HashSet<Integer> bipartitions = calculateBipartitions(m);

		//		prettyPrintBipartitions(bipartitions);

		/*
		 * if there's a loop, then deleting a link in the loop will still
		 * leave all organisms connected
		 * 
		 * thus, if any one (or more) bipartitions contains all organisms
		 * (2^20 -1), then there's at least one loop.
		 */
		if (bipartitions.contains(new Integer((int)Math.pow(2,20) - 1))) {
			b.append("<font size=-2>Your tree contains one or more <font color=blue>loops</font>.</font></html>");
			return b.toString();
		}

		/*
		 * if they've gotten this far, we can calculate a score using 
		 * Robinson-Foulds distance
		 */
		int rfdist = calculateRFDistance(bipartitions, CorrectTreeBipartitionSet.getSet());
		if (rfdist > 0) b.append("<font color=red>");
		b.append("<font size=-2>The error in your tree is ");
		b.append(rfdist);
		b.append("; ideally, it should be 0.</font>");
		if (rfdist > 0) b.append("</font>");
		b.append("</html>");
		return b.toString();
	}

	public Graph makeGraph(StudentModel m) {
		Graph graph = new Graph("Bio student");
		List<Connection> connections = new LinkedList<Connection>();
		for (ModelElement element : m.inTreeElements()) { // load vertices
			if (element instanceof Node)
				graph.addVertex(element.getId(), ((Node) element)
						.convertToVertex());
			else
				connections.add((Connection) element);
		}
		for (Connection c : connections) {
			Vertex v1 = graph.getVertexByID(c.getFrom().getId());
			Vertex v2 = graph.getVertexByID(c.getTo().getId());
			graph.addEdge(new Edge(v1, v2));
		}
		return graph;
	}

	/*
	 * part of Robinson-Foulds tree-to-tree distance calculation
	 * 
	 * break each connection one by one and see which orgs are
	 * on which side of the break (a bipartition)
	 * - returns bipartition as integer bitmap of organisms
	 * 
	 * only works if no cycles (loops)
	 */
	public HashSet<Integer> calculateBipartitions(StudentModel m) {

		Vertex startingVertexForSearch = null;

		HashSet<Integer> bipartitions = new HashSet<Integer>();

		// read in model elements
		LinkedList<VertexWithId> verticesAndIds = new LinkedList<VertexWithId>();
		LinkedList<Connection> connections = new LinkedList<Connection>();
		for (ModelElement element : m.inTreeElements()) {
			if (element instanceof Node) {
				Vertex vertex = ((Node) element).convertToVertex();
				verticesAndIds.add(
						new VertexWithId(element.getId(), vertex));

				// find vertex(0) - Bat - to use as start for bipartition search
				if (element.getId() == 0) {
					startingVertexForSearch = vertex;
				}
			} else {
				connections.add((Connection) element);
			}
		}

		// error condition - you should ALWAYS find bat...
		if (startingVertexForSearch == null) return null;

		// build graphs with a single missing link
		// and find bipartition for each
		for (Connection leaveMeOut : connections) {

			Graph graph = new Graph("Bio student");

			// use all vertices
			for (VertexWithId vi : verticesAndIds) {
				vi.vertex.clearAll();	// erase markings from previous runs
				graph.addVertex(vi.id, vi.vertex);
			}

			// all connections except one
			for (Connection c : connections) {
				if (c.getId() != leaveMeOut.getId()) {
					Vertex v1 = graph.getVertexByID(c.getFrom().getId());
					Vertex v2 = graph.getVertexByID(c.getTo().getId());
					graph.addEdge(new Edge(v1, v2));
				}
			}
			bipartitions.add(new Integer(graph.membersOfSameTreeAs(startingVertexForSearch)));
		}
		return bipartitions;
	}

	private class VertexWithId {
		public Vertex vertex;
		public int id;
		public VertexWithId(int id, Vertex v) {
			this.id = id;
			this.vertex = v;
		}		
	}

	/*
	 * for printing the bipartitions of a tree in a format
	 * that can be used to generate a reference set for 
	 * comparision
	 * for example, the bipartitions of the correct tree
	 * this output can be used to generate the java code
	 * to make the correct set of bipartitions.
	 */
	private void prettyPrintBipartitions(HashSet<Integer> bipartitions) {
		for (Integer i : bipartitions) {
			System.out.println("set.add(Integer.parseInt(\"" + Integer.toBinaryString(i) + "\", 2));");
		}
	}

	/*
	 * calculates Robinson-Foulds distance
	 */
	private int calculateRFDistance(
			HashSet<Integer>studentTreeBipartitions, 
			HashSet<Integer>correctTreeBipartitions) {
		int missing = 0;
		int extra = 0;

		for (Integer i : correctTreeBipartitions) {
			if (!studentTreeBipartitions.contains(i)) missing++;
		}

		for (Integer i : studentTreeBipartitions) {
			if (!correctTreeBipartitions.contains(i)) extra++;
		}
		return (extra + missing)/2;
	}

	/*
	 * opens a folder of tree files and makes a scores.csv file
	 * of their scores in that directory
	 */
	public File getTreeFileDirectory() {
		JFileChooser chooser = new JFileChooser(
				new File(
						System.getProperty("user.home") + 
						System.getProperty("file.separator") + 
				"Desktop"));
		chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
		chooser.setDialogTitle("Choose a DIRECTORY where the .tree files can be found");
		int result = chooser.showOpenDialog(this);
		if (result == JFileChooser.APPROVE_OPTION) {
			return chooser.getSelectedFile();
		} else {
			return null;
		}
	}

	private void openManyTreesForScoring() {
		File treeDir = getTreeFileDirectory();
		if (treeDir != null) {
			StringBuffer scoresBuffer = new StringBuffer();
			scoresBuffer.append("Name,UsedAllOrgs,ConnectedAllOrgs,AllEndsOfBranches,AllEmptyConnected,AllEmptyTerminal,NoLoops,Error\n");

			int filesOpened = 0;
			File[] files = treeDir.listFiles();
			for (File file : files) {
				if (file.getName().endsWith(ApplicationFrame.TREE_FILE_EXTENSION)) {

					filesOpened++;
					String studentName = file.getName().replaceAll(ApplicationFrame.TREE_FILE_EXTENSION, "");

					StringBuffer buffer = new StringBuffer();
					try {
						BufferedReader reader = new BufferedReader(new FileReader(file));
						String line = null;
						while (( line = reader.readLine()) != null){
							buffer.append(line);
							buffer.append(System.getProperty("line.separator"));
						}

						reader.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
					String studentTreeData = buffer.toString();
					StudentModel m = new StudentModel(this, organisms, studentTreeData);

					scoresBuffer.append(studentName);
					scoresBuffer.append(",");

					if (!m.getStudent().getTree().equals("")) {

						Graph graph = makeGraph(m);

						if (m.unusedOrganisms().length() != 0) {
							scoresBuffer.append("N,-,-,-,-,-,-\n");
						} else if (!graph.allOrganismsConnected()) {
							scoresBuffer.append("Y,N,-,-,-,-,-\n");
						} else if (!graph.allOrganismsTerminal()) {
							scoresBuffer.append("Y,Y,N,-,-,-,-\n");
						} else if (graph.hasUnconnectedBranchPoints()) {
							scoresBuffer.append("Y,Y,Y,N,-,-,-\n");
						} else if (graph.hasTerminalBranchPoints()) {
							scoresBuffer.append("Y,Y,Y,Y,N,-,-\n");
						} else {
							HashSet<Integer> bipartitions = calculateBipartitions(m);
							if (bipartitions.contains(new Integer((int)Math.pow(2,20) - 1))) {
								scoresBuffer.append("Y,Y,Y,Y,Y,N,-\n");
							} else {
								scoresBuffer.append("Y,Y,Y,Y,Y,Y,");
								scoresBuffer.append(
										calculateRFDistance(
												bipartitions, 
												CorrectTreeBipartitionSet.getSet()));
								scoresBuffer.append("\n");
							}
						}
					} else {
						scoresBuffer.append("Unreadable,-,-,-,-,-,-\n");
					}
				}
			}


			File outFile = new File(treeDir.getAbsolutePath() + 
					System.getProperty("file.separator") + "scores.csv");
			try {
				BufferedWriter out = new BufferedWriter(new FileWriter(outFile));
				out.write(scoresBuffer.toString());
				out.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
			JOptionPane.showMessageDialog(this, "I just saved the results of scoring " 
					+ filesOpened + " student files\n to " + outFile.getAbsolutePath());
		}
	}

	private List<Student> loadStudents(Graphics2D g2, String allStudentStrings) {

		TBSGraphics.studentNodeHeight = 0;
		List<Student> students = new LinkedList<Student>();
		int lines = 0;

		String[] studentStrings = allStudentStrings.split(ApplicationFrame.CONCATENATION_SEQUENCE);
		for (int i = 0; i < studentStrings.length; i++) {
			Student temp = new Student(studentStrings[i], i);
			temp.setNodeName(TBSGraphics.breakStringByLineWidth(g2, temp
					.getName(), TBSGraphics.maxStudentNameWidth));
			if (temp.getNodeName().size() > lines)
				lines = temp.getNodeName().size();

			students.add(temp);
		}
		TBSGraphics.studentNodeHeight = lines * TBSGraphics.textHeight;
		TBSGraphics.studentNodeHeight += TBSGraphics.padding.width * 2;
		return students;
	}

}
